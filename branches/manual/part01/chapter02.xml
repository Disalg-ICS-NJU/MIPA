<?xml version="1.0" encoding="UTF-8"?>
<chapter id="mipa.a-simple-example">
  <title>Getting Started</title>

  <para>In this chapter, we will show how to use the MIPA middleware infrastructuer via a 'Hello World!' example.
  </para>
  
  <important>
	<para>MIPA is developed purely in Java.</para>
	<para>All configuration files are written in XML.</para>
  </important>
  
  <para> To achieve context-awareness based on MIPA, the application simplely needs to take 5 steps:  
  </para>
  <para> ??? the application simply needs to specify and send the predicate, and wait for the respose. (it may also need to ensure the specified context is supported. ) then, MIPA needs to do xxx steps. </para>
  <orderedlist>
	<listitem><para>Specify the context property it is concerned with </para></listitem>
	<listitem><para>Implement the callback interface
	  </para></listitem>
	<listitem><para>Configure the sensor agents for sensors</para></listitem>
	<listitem><para>Configure system</para></listitem>
	<listitem><para>Launch system</para></listitem>
  </orderedlist>
  
  <sect1 id="mipa.a-simple-example.predicate">
	<title>Specifying a Predicate</title>
  
	<para>We provide the <link linkend="mipa.principle.predicate.definition">PDCC
	  framework</link> for users to specify their RECA. (??? Based on PDCC, application delineates its RECA using predicates.)Here is an
	example of a predicate delineating an application's RECA.
	</para>
  
	<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE predicate SYSTEM "predicate.dtd"&gt;
&lt;predicate type="SCP"&gt;
  &lt;prefix value="def" /&gt;
  &lt;GSE value="conjunction"&gt;
    &lt;CGS value="conjunction"&gt;
      &lt;LP&gt;
	&lt;formula&gt;
	  &lt;atom operator="great-than" name="light" value="500" /&gt;
	&lt;/formula&gt;
      &lt;/LP&gt;
      &lt;LP&gt;
	&lt;formula&gt;
	  &lt;atom operator="not-contain" name="RFID" value="tag_00001" /&gt;
	&lt;/formula&gt;
      &lt;/LP&gt;
    &lt;/CGS&gt;
    &lt;global&gt;g&lt;/global&gt;
  &lt;/GSE&gt;
&lt;/predicate&gt;
</programlisting>
	<para>
	  In this example, the user is interested in the events of light and RFID. If
	  <code>light &gt; 500</code> and <code>RFID not-contain tag_00001</code>
	occur simultaneously, the application should be notified.
	</para>
  </sect1>

  
  <sect1 id="mipa.a-simple-example.application">
	<title>Implementing the Callback Interface (???)</title>
  
	<para>The application of the MIPA should implement the callback interface 
	which the MIPA call for notifying it.</para>
	
	<para>In this example, when the predicate is true, the application just
	  prints "Hello World!". The callback code is shown below.
	</para>
  
	<programlisting>
import net.sourceforge.mipa.application.AbstractApplication;

public class Application extends AbstractApplication {

      public void callback(String value) throws RemoteException {
            System.out.println("Hello World!");
      }
}
</programlisting>
  
  </sect1>

  <sect1 id="mipa.a-simple-example.sensor">
	<title>Writing Agents for Sensors (??? configuring sensor agents)</title>
	
	<para>This step is optional. It dues to the existing sensors. If the
	existing contexts satisfy the predicate, you just skip this step. (???)
	</para>
	
	<para>MIPA integrates sensors as plug-ins. If there is no existing
	context that the predicate uses. All you should do is writing the sensors
	which the context relates to. In order to archive this target, you should
	write sensors classes and configure them. (??? two different things mixed up)
	</para>
  
	<para>Here is a simulated RFID sensor class. All sensors in the MIPA
	  middleware should implement the interface of <code>Sensor</code>.
	</para>
	
	<programlisting>
public class SimulationRFID implements Sensor {

    /** time gap between continuous data generations. */
    private long gap;

    /** tags that RFID reader manages. */
    private ArrayList&lt;String&gt; tags;

    /** data source per tag. */
    private ArrayList&lt;String&gt; sources;

    /** data source indicator per tag. */
    private int[] indicators;

    public SimulationRFID(Object args) {

        try {
            BufferedReader source = new BufferedReader(
                                               new FileReader((String) Array.get(args, 0)));
            
            gap = Long.parseLong(source.readLine());
            int num = Integer.parseInt(source.readLine());
            tags = new ArrayList&lt;String&gt;();
            sources = new ArrayList&lt;String&gt;();
            indicators = new int[num];
            
            for (int i = 0; i &lt; num; i++) {
                String tag = source.readLine();
                tags.add(tag);
            }
            for (int i = 0; i &lt; num; i++) {
                String data = source.readLine();
                sources.add(data);
            }

            for (int i = 0; i &lt; num; i++) {
                indicators[i] = 0;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public String[] getData() {
        ArrayList&lt;String&gt; detectedTags = new ArrayList&lt;String&gt;();

        for (int i = 0; i &lt; indicators.length; i++) {
            String source = sources.get(i);
            if (source.length() &lt;= indicators[i])
                continue;
            
            if (source.charAt(indicators[i]) != '0')
                detectedTags.add(tags.get(i));
              
            indicators[i]++;
        }
        
        if (detectedTags.size() != 0) {
            String[] detectedTagsArray = new String[detectedTags.size()];
            detectedTags.toArray(detectedTagsArray);
            return detectedTagsArray;
        } else {
            boolean end = true;
            for(int i = 0; i &lt; indicators.length; i++) {
                if(sources.get(i).length() &gt; indicators[i]) {
                    end = false;
                    break;
                }
            }
            String[] results = {""};
            if (end == true) results = null;
            return results;
        }
    }

    public long getGap() {
        return gap;
    }
}
</programlisting>
	
	<para>
	After implementing the sensor class, the user is going to configure the
	  sensor through a configuration file. All fields of the configuration file will
	  be explained in <link linkend="mipa.usage.user.sensor">Chapter 3</link>.
	</para>
	<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE sensor SYSTEM "sensor.dtd"&gt;
&lt;sensor&gt;
  &lt;name&gt;RFID&lt;/name&gt;
  &lt;id&gt;RFID&lt;/id&gt;
  &lt;class&gt;net.sourceforge.mipa.eca.sensor.SimulationRFID&lt;/class&gt;
  &lt;location&gt;nju&lt;/location&gt;
  &lt;ValueType&gt;String&lt;/ValueType&gt;
  &lt;DataSchema type="push" /&gt;
  &lt;DataDisseminate time="1" lazy="false" /&gt;
  &lt;arguments&gt;
	&lt;argument&gt;data/RFID&lt;/argument&gt;
  &lt;/arguments&gt;
&lt;/sensor&gt;
</programlisting>
  </sect1>

  <sect1 id="mipa.a-simple-example.system-config">
	<title>Configuring System</title>
  
	<para>Before we run the MIPA, the system should be configured. An example of
	a system configuration file is shown below. In this edition, we should
	configure the IP and port of a naming service, usually it is located in the
	  same address as the <link linkend="mipa.principle.pd">Predicate Detection
	  Side</link>.
	</para>
	
	<para>In this example, we choose <code>normal</code> mode of <code>check
	  mode</code>. The mode will be explained in <link linkend="">XXX</link> Section.
	</para>
  
	<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE config SYSTEM "config.dtd"&gt;
&lt;config&gt;
	&lt;naming&gt;
		&lt;address&gt;127.0.0.1&lt;/address&gt;
		&lt;port&gt;1099&lt;/port&gt;
	&lt;/naming&gt;
	&lt;!-- normal or lattice --&gt;
	&lt;checkmode&gt;normal&lt;/checkmode&gt;
&lt;/config&gt;
</programlisting>
  </sect1>

  <sect1 id="mipa.a-simple-example.start-system">
	<title>Launching System</title>
  
	<para>Now, let's launch the system.</para>
  
	<para>MIPA consists of two sides: (PD-side and ECA-side) <code>Predicate
	  Detection Side</code> and <code>ECA Side</code>. At any time, there are
	  one instance of the <code>Predicate Detection Side</code> and many instances of
	  the <code>ECA Side</code> (???). They are running in (???) distributed
	environment.
	</para>
  
	<para>Launch scripts are located in <code>${MIPA Home}/bin</code>, it supports
	both Linux and Windows operating systems. In this manual, we take Linux for
	example.
	</para>
  
	<para>The steps of starting <code>Predicate Detection Side</code>: (Please
	  replace <code>${MIPA Home}</code> as the actual value in your system)</para>
  
	<orderedlist>
	  <listitem><para><code>$cd ${MIPA Home}/bin/linux</code></para></listitem>
	  <listitem><para><code>$./MIPAInitialize</code></para></listitem>
	</orderedlist>
  
	<para>The naming service is also launching at <code>Predicate Detection Side</code></para>
  
	<para>You can launch the <code>ECA Side</code> in the same computer of the
	  <code>Predicate Detection Side</code> or in a new computer as you like.
	</para>
  
	<para>The steps of launching an <code>ECA Side</code>:</para>
  
	<orderedlist>
	  <listitem><para><code>$cd ${MIPA Home}/bin/linux</code></para></listitem>
	  <listitem><para><code>$./ECAInitialize</code></para></listitem>
	</orderedlist>
  
	<para>In the last step, an application should be started. We supply an example
	whose start script is located in the same directory as others.
	</para>
  
	<para>The steps of launching the example:</para>
  
	<orderedlist>
	  <listitem><para><code>$cd ${MIPA Home}/bin/linux</code></para></listitem>
	  <listitem><para><code>$./application 1</code></para></listitem>
	</orderedlist>
  </sect1>
</chapter>